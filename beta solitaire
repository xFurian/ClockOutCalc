<!DOCTYPE html>
<html lang="en">
<head>
<!-- CSS Styling -->
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Classic Solitaire</title>
<style>
  :root{
    --pile-w: clamp(60px, 11vw, 100px);
    --pile-h: calc(var(--pile-w) * 1.4);
    --stack-gap: 20px;
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: #808080;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    overscroll-behavior: none;
  }

  h1 {
    color: #fff;
    margin: 16px 0 6px;
    text-align: center;
    font-weight: 700;
    font-size: clamp(18px, 4vw, 28px);
  }

  .board {
    width: 100%;
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 10px 30px;
  }

  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 12px;
  }

  .top-row {
    display: flex;
    gap: 10px;
    flex-wrap: nowrap;
    justify-content: flex-start;
    flex: 1 1 auto;
  }

  .stock-waste {
    display: flex;
    gap: 10px;
  }

  .foundations {
    display: flex;
    gap: 10px;
    margin-left: auto;
  }

  .right-side {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
  }

  .controls {
    display: flex;
    gap: 6px;
    flex: 0 0 auto;
    flex-wrap: wrap;
    justify-content: flex-end;
  }

  .piles-group { display: contents; }

  .pile {
    width: var(--pile-w);
    height: var(--pile-h);
    border: 2px solid #d3d3d3;
    background: #808080;
    position: relative;
    border-style: solid;
    flex-shrink: 0;
  }

  #waste { width: calc(var(--pile-w) + 40px); }

  .foundation, .tableau { border-style: dashed; }

  .card {
    width: calc(100% - 10px);
    height: calc(100% - 14px);
    border: 1px solid #003366;
    background: #fff;
    position: absolute;
    left: 5px;
    top: 5px;
    padding: 6px;
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: clamp(12px, 2.4vw, 20px);
    user-select: none;
    cursor: move;
    touch-action: none;
  }
  .card.red { color: red; }
  .card.face-down {
    background: #000;
    color: #fff;
    cursor: default;
  }
  .card.moving { opacity: 0.5; }

  #tableau-row {
    display: flex;
    gap: 10px;
    flex-wrap: nowrap;
    justify-content: space-between;
  }

  button {
    padding: 10px 16px;
    font-size: clamp(12px, 2.5vw, 14px);
    background: linear-gradient(to bottom, #f2f2f2, #d9d9d9);
    border: 1px solid #888;
    border-radius: 4px;
    box-shadow: inset 0 1px 0 #fff, 0 1px 2px rgba(0,0,0,0.2);
    cursor: pointer;
  }
  button:hover { background: linear-gradient(to bottom, #ffffff, #cfcfcf); }
  button:active {
    background: linear-gradient(to bottom, #cfcfcf, #ffffff);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }

  .pile.drag-over {
    outline: 3px dashed rgba(255,255,255,0.7);
    outline-offset: -3px;
  }

  #touch-ghost {
    position: absolute;
    pointer-events: none;
    z-index: 9999;
  }

  #reshuffle-circle {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(20px, 4vw, 30px); /* Larger refresh symbol */
    color: #003366; /* Blue color for the symbol */
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  #reshuffle-circle.visible {
    opacity: 1;
  }
  #reshuffle-circle.spin {
    animation: spin 0.5s linear;
  }
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .stats {
    color: #fff;
    text-align: right;
    font-size: clamp(12px, 2.5vw, 16px);
    flex: 0 0 auto;
    white-space: nowrap;
  }

  @media (max-width: 800px) {
    .top-bar {
      flex-direction: column;
      align-items: stretch;
      gap: 12px;
    }
    .top-row {
      justify-content: space-between;
    }
    .foundations {
      margin-left: 0;
    }
    .right-side {
      align-items: center;
    }
    .controls {
      justify-content: center;
    }
    .stats {
      text-align: center;
    }
    #tableau-row {
      justify-content: center;
      flex-wrap: wrap;
    }
  }
</style>
</head>
<body>
<!-- HTML Structure -->
  <h1>Solitaire</h1>

  <div class="board">
    <div class="top-bar">
      <div class="top-row">
        <div class="stock-waste">
          <div id="stock" class="pile" onclick="drawCard()">
            <div id="reshuffle-circle">↻</div>
            <div id="stock-card"></div>
          </div>
          <div id="waste" class="pile"></div>
        </div>
        <div class="foundations">
          <div id="foundation1" class="pile foundation"></div>
          <div id="foundation2" class="pile foundation"></div>
          <div id="foundation3" class="pile foundation"></div>
          <div id="foundation4" class="pile foundation"></div>
        </div>
      </div>
      <div class="right-side">
        <div id="stats" class="stats">Moves: 0 Time: 0:00</div>
        <div class="controls">
          <button onclick="newGame()">New Game</button>
          <button onclick="undo()">Undo</button>
          <button onclick="openSettings()">Settings</button>
          <button onclick="window.location.href='http://www.protoncube.com/'">Back to Calculator</button>
        </div>
      </div>
    </div>

    <div id="tableau-row">
      <div id="tableau1" class="pile tableau"></div>
      <div id="tableau2" class="pile tableau"></div>
      <div id="tableau3" class="pile tableau"></div>
      <div id="tableau4" class="pile tableau"></div>
      <div id="tableau5" class="pile tableau"></div>
      <div id="tableau6" class="pile tableau"></div>
      <div id="tableau7" class="pile tableau"></div>
    </div>
  </div>

  <div id="settings-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; align-items:center; justify-content:center;">
    <div style="background:#fff; padding:20px; border-radius:8px; width:80%; max-width:400px;">
      <h2>Settings</h2>
      <div>
        <p>Draw cards:</p>
        <label><input type="radio" name="drawNum" value="1" checked> 1 card</label><br>
        <label><input type="radio" name="drawNum" value="3"> 3 cards</label>
      </div>
      <div>
        <p>Auto-complete:</p>
        <label><input type="checkbox" id="autoCompleteCheck" checked> Enabled</label>
      </div>
      <div>
        <p>Auto-move on click:</p>
        <label><input type="checkbox" id="autoMoveCheck" checked> Enabled</label>
      </div>
      <div style="margin-top:20px; display:flex; justify-content:space-between;">
        <button onclick="applySettings()">Apply and New Game</button>
        <button onclick="closeSettings()">Cancel</button>
      </div>
    </div>
  </div>

<script>
// JavaScript Data
const suits = ['♠', '♣', '♥', '♦'];
const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
let deck = [], stock = [], waste = [], foundations = [[],[],[],[]], tableau = [[],[],[],[],[],[],[]];

let touchDragData = null;
let lastTapTime = 0;
let drawNum = 1;
let autoCompleteEnabled = true;
let autoMoveEnabled = true;
let history = [];
let moves = 0;
let timer = 0;
let interval = null;

// JavaScript Setup Functions
function createDeck(){
  deck = [];
  for (let suit of suits){
    for (let rank of ranks){
      deck.push({ suit, rank, color: (suit === '♥' || suit === '♦') ? 'red' : 'black', faceUp: false });
    }
  }
  shuffle(deck);
}

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function dealCards(){
  stock = []; waste = []; foundations = [[],[],[],[]]; tableau = [[],[],[],[],[],[],[]];
  const deckCopy = deck.slice();
  for (let i = 0; i < 7; i++){
    for (let j = i; j < 7; j++){
      const card = deckCopy.pop();
      card.faceUp = (i === j);
      tableau[j].push(card);
    }
  }
  stock = deckCopy;
  renderWithBindings();
}

// JavaScript Rendering Functions
function render(){
  // Stock
  const stockCardEl = document.getElementById('stock-card');
  stockCardEl.innerHTML = stock.length ? '<div class="card face-down"></div>' : '';
  const reshuffleCircle = document.getElementById('reshuffle-circle');
  reshuffleCircle.classList.toggle('visible', stock.length === 0);

  // Waste
  const wasteEl = document.getElementById('waste');
  wasteEl.innerHTML = '';
  const showCount = Math.min(3, waste.length);
  const showStart = waste.length - showCount;
  for (let i = showStart; i < waste.length; i++) {
    const el = createCardElement(waste[i], 'waste', i);
    el.style.left = `${(i - showStart) * 20}px`;
    el.style.top = '5px';
    wasteEl.appendChild(el);
  }

  // Foundations
  for (let i = 0; i < 4; i++){
    const fEl = document.getElementById(`foundation${i + 1}`);
    fEl.innerHTML = '';
    if (foundations[i].length > 0){
      fEl.appendChild(createCardElement(foundations[i][foundations[i].length - 1], `foundation${i + 1}`, foundations[i].length - 1));
    }
  }

  // Tableau
  for (let i = 0; i < 7; i++){
    const tEl = document.getElementById(`tableau${i + 1}`);
    tEl.innerHTML = '';
    tableau[i].forEach((card, index) => {
      const el = createCardElement(card, `tableau${i + 1}`, index);
      el.style.top = `${index * 20}px`;
      tEl.appendChild(el);
    });
  }
}

function createCardElement(card, pileId, index){
  const div = document.createElement('div');
  div.className = 'card' + (card.faceUp ? '' : ' face-down');

  if (card.faceUp){
    div.textContent = `${card.rank}${card.suit}`;
    div.classList.add(card.color);

    const pileArr = getPileArray(pileId);
    if (pileId === 'waste' && index !== pileArr.length - 1) {
      div.draggable = false;
      div.style.cursor = 'default';
    } else {
      div.draggable = true;
      div.addEventListener('dragstart', e => dragStart(e, pileId, index));
    }

    const isLast = index === pileArr.length - 1 && (pileId === 'waste' || pileId.startsWith('tableau'));
    if (isLast && autoMoveEnabled){
      div.addEventListener('click', () => autoMoveToFoundation(pileId, index));
    }

    div.addEventListener('touchstart', e => handleCardTouchStart(e, pileId, index), { passive: false });
  }

  div.addEventListener('dragover', e => e.preventDefault());
  div.addEventListener('drop', e => drop(e, pileId));
  return div;
}

function renderWithBindings(){
  render();
  attachPileDropTargets();
  updateStats();
}

function updateStats() {
  document.getElementById('stats').innerHTML = `Moves: ${moves} Time: ${Math.floor(timer / 60)}:${(timer % 60).toString().padStart(2, '0')}`;
}

// JavaScript Drag-and-Drop Handling
function isValidSequence(cards){
  for (let k = 1; k < cards.length; k++){
    if (ranks.indexOf(cards[k].rank) !== ranks.indexOf(cards[k - 1].rank) - 1) return false;
    if (cards[k].color === cards[k - 1].color) return false;
  }
  return true;
}

function dragStart(e, pileId, index){
  if (pileId.startsWith('foundation')) {
    e.preventDefault();
    return;
  }
  const src = getPileArray(pileId);
  const moving = src.slice(index);

  if (pileId.startsWith('tableau') && moving.length > 1 && !isValidSequence(moving)){
    e.preventDefault();
    return;
  }

  e.dataTransfer.setData('text/plain', JSON.stringify({ pileId, index }));
}

function attachPileDropTargets(){
  document.querySelectorAll('.pile').forEach(pileEl => {
    pileEl.addEventListener('dragover', e => { e.preventDefault(); pileEl.classList.add('drag-over'); });
    pileEl.addEventListener('dragleave', () => pileEl.classList.remove('drag-over'));
    pileEl.addEventListener('drop', e => { pileEl.classList.remove('drag-over'); drop(e, pileEl.id); });
  });
}

// JavaScript Touch Handling
function handleCardTouchStart(e, pileId, index){
  if (!getPileArray(pileId)[index].faceUp) return;
  if (pileId.startsWith('foundation')) return;
  e.preventDefault();

  const now = Date.now();
  if (now - lastTapTime < 300){
    if (autoMoveEnabled) autoMoveToFoundation(pileId, index);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;

  const src = getPileArray(pileId);
  const moving = src.slice(index);
  if (pileId.startsWith('tableau') && moving.length > 1 && !isValidSequence(moving)) return;
  if (pileId === 'waste' && index !== src.length - 1) return;

  touchDragData = { pileId, index };

  const ghost = document.createElement('div');
  ghost.id = 'touch-ghost';
  moving.forEach((card, i) => {
    const mini = document.createElement('div');
    mini.className = 'card' + (card.faceUp ? '' : ' face-down');
    if (card.faceUp){
      mini.textContent = `${card.rank}${card.suit}`;
      mini.classList.add(card.color);
    }
    mini.style.position = 'absolute';
    mini.style.left = '0';
    mini.style.top = `${i * 20}px`;
    mini.style.width = `calc(${getComputedStyle(document.querySelector('.pile')).width} - 10px)`;
    mini.style.height = `calc(${getComputedStyle(document.querySelector('.pile')).height} - 14px)`;
    ghost.appendChild(mini);
  });
  document.body.appendChild(ghost);

  document.addEventListener('touchmove', handleTouchMove, { passive: false });
  document.addEventListener('touchend', handleTouchEnd, { passive: false });
}

function handleTouchMove(e){
  if (!touchDragData) return;
  e.preventDefault();
  const t = e.touches[0];
  const ghost = document.getElementById('touch-ghost');
  if (ghost){
    ghost.style.left = (t.pageX - parseInt(getComputedStyle(document.querySelector('.pile')).width)/2) + 'px';
    ghost.style.top  = (t.pageY - parseInt(getComputedStyle(document.querySelector('.pile')).height)/2) + 'px';
  }
}

function handleTouchEnd(e){
  if (!touchDragData) return;

  const t = e.changedTouches[0];
  const el = document.elementFromPoint(t.clientX, t.clientY);
  const targetPileEl = el ? el.closest('.pile') : null;

  const ghost = document.getElementById('touch-ghost');
  if (ghost) ghost.remove();

  if (targetPileEl){
    drop(new Event('drop'), targetPileEl.id);
  }

  touchDragData = null;
  document.removeEventListener('touchmove', handleTouchMove);
  document.removeEventListener('touchend', handleTouchEnd);
}

// JavaScript Game Logic
function getPileArray(id){
  if (id === 'waste') return waste;
  if (id.startsWith('foundation')) return foundations[parseInt(id[10]) - 1];
  if (id.startsWith('tableau')) return tableau[parseInt(id[7]) - 1];
  return null;
}

function isValidMove(targetId, movingCard, targetPile){
  if (!movingCard) return false;

  if (targetId.startsWith('foundation')){
    if (targetPile.length === 0) return movingCard.rank === 'A';
    return movingCard.suit === targetPile[targetPile.length - 1].suit &&
           ranks.indexOf(movingCard.rank) === ranks.indexOf(targetPile[targetPile.length - 1].rank) + 1;
  } else if (targetId.startsWith('tableau')){
    if (targetPile.length === 0) return movingCard.rank === 'K';
    const topCard = targetPile[targetPile.length - 1];
    return movingCard.color !== topCard.color &&
           ranks.indexOf(movingCard.rank) === ranks.indexOf(topCard.rank) - 1;
  }
  return false;
}

function drop(e, targetPileId){
  e.preventDefault();

  let data = null;
  if (e.dataTransfer){
    const text = e.dataTransfer.getData('text');
    if (text) data = JSON.parse(text);
  }
  if (!data && touchDragData) data = touchDragData;
  if (!data) return;

  const { pileId, index } = data;
  if (pileId === targetPileId) return;

  const sourcePile = getPileArray(pileId);
  const targetPile = getPileArray(targetPileId);
  if (!sourcePile || !targetPile) return;
  if (targetPileId === 'stock' || targetPileId === 'waste') return;

  let movingCards = sourcePile.slice(index);

  if (pileId.startsWith('tableau') && movingCards.length > 1 && !isValidSequence(movingCards)) return;

  if (targetPileId.startsWith('foundation') && movingCards.length > 1){
    movingCards = [movingCards[0]];
  }

  if (isValidMove(targetPileId, movingCards[0], targetPile)){
    history.push(deepCopyState());
    moves++;
    sourcePile.splice(index, movingCards.length);
    targetPile.push(...movingCards);

    if (pileId.startsWith('tableau') && sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp){
      sourcePile[sourcePile.length - 1].faceUp = true;
    }
    renderWithBindings();
    checkWin();
  }
}

function drawCard(){
  console.log('drawCard called, stock length:', stock.length, 'waste length:', waste.length);
  if (stock.length > 0){
    history.push(deepCopyState());
    moves++;
    for (let i = 0; i < drawNum && stock.length > 0; i++) {
      const card = stock.pop();
      card.faceUp = true;
      waste.push(card);
      console.log('Drew card:', card);
    }
  } else if (waste.length > 0){
    history.push(deepCopyState());
    moves++;
    const reshuffleCircle = document.getElementById('reshuffle-circle');
    reshuffleCircle.classList.add('spin');
    setTimeout(() => reshuffleCircle.classList.remove('spin'), 500);
    stock = waste.reverse().map(c => ({ ...c, faceUp: false }));
    waste = [];
    console.log('Reshuffled, new stock length:', stock.length);
  } else if (isAllFaceUp() && autoCompleteEnabled){
    history.push(deepCopyState());
    moves++;
    console.log('All face up, running autoComplete');
    autoComplete();
  }
  renderWithBindings();
}

function isAllFaceUp(){
  return tableau.every(pile => pile.every(card => card.faceUp));
}

function autoComplete(){
  let moved;
  do {
    moved = false;
    if (waste.length > 0){
      const card = waste[waste.length - 1];
      for (let i = 0; i < 4; i++){
        const f = foundations[i];
        if (isValidMove(`foundation${i + 1}`, card, f)){
          waste.pop(); f.push(card); moved = true; break;
        }
      }
    }
    for (let j = 0; j < 7; j++){
      const t = tableau[j];
      if (t.length > 0){
        const card = t[t.length - 1];
        for (let i = 0; i < 4; i++){
          const f = foundations[i];
          if (isValidMove(`foundation${i + 1}`, card, f)){
            t.pop(); f.push(card); moved = true; break;
          }
        }
      }
    }
  } while (moved);
  renderWithBindings();
  checkWin();
}

function autoMoveToFoundation(pileId, index){
  const sourcePile = getPileArray(pileId);
  if (!sourcePile || index !== sourcePile.length - 1) return;
  const card = sourcePile[index];
  for (let i = 0; i < 4; i++){
    const f = foundations[i];
    if (isValidMove(`foundation${i + 1}`, card, f)){
      history.push(deepCopyState());
      moves++;
      sourcePile.pop();
      f.push(card);
      if (pileId.startsWith('tableau') && sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp){
        sourcePile[sourcePile.length - 1].faceUp = true;
      }
      renderWithBindings();
      checkWin();
      return;
    }
  }
}

function checkWin(){
  const total = foundations.reduce((s,f) => s + f.length, 0);
  if (total === 52) alert('Congratulations! You won!');
}

function deepCopyState() {
  return {
    stock: stock.map(c => ({...c})),
    waste: waste.map(c => ({...c})),
    foundations: foundations.map(f => f.map(c => ({...c}))),
    tableau: tableau.map(t => t.map(c => ({...c})))
  };
}

function undo() {
  if (history.length === 0) return;
  const prev = history.pop();
  stock = prev.stock;
  waste = prev.waste;
  foundations = prev.foundations;
  tableau = prev.tableau;
  renderWithBindings();
}

function openSettings() {
  document.getElementById('settings-modal').style.display = 'flex';
  const radios = document.querySelectorAll('input[name="drawNum"]');
  for (let r of radios) {
    if (parseInt(r.value) === drawNum) r.checked = true;
  }
  document.getElementById('autoCompleteCheck').checked = autoCompleteEnabled;
  document.getElementById('autoMoveCheck').checked = autoMoveEnabled;
}

function closeSettings() {
  document.getElementById('settings-modal').style.display = 'none';
}

function applySettings() {
  drawNum = parseInt(document.querySelector('input[name="drawNum"]:checked').value);
  autoCompleteEnabled = document.getElementById('autoCompleteCheck').checked;
  autoMoveEnabled = document.getElementById('autoMoveCheck').checked;
  closeSettings();
  newGame();
}

function newGame(){
  if (interval) clearInterval(interval);
  timer = 0;
  moves = 0;
  history = [];
  updateStats();
  interval = setInterval(() => { timer++; updateStats(); }, 1000);
  createDeck();
  dealCards();
}

// JavaScript Boot Process
newGame();
</script>
</body>
</html>
