<!DOCTYPE html>
<html lang="en">
<head>
<!-- CSS Styling -->
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Classic Solitaire</title>
<style>
  :root{
    --pile-w: clamp(60px, 11vw, 100px);
    --pile-h: calc(var(--pile-w) * 1.4);
    --stack-gap: 20px;
  }

  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: #808080;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    overscroll-behavior: none;
  }

  h1 {
    color: #fff;
    margin: 16px 0 6px;
    text-align: center;
    font-weight: 700;
    font-size: clamp(18px, 4vw, 28px);
  }

  .board {
    width: 100%;
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 10px 30px;
  }

  .top-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin-bottom: 12px;
  }

  .top-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
    flex: 1 1 auto;
  }

  .controls {
    display: flex;
    gap: 6px;
    flex: 0 0 auto;
  }

  .piles-group { display: contents; }

  .pile {
    width: var(--pile-w);
    height: var(--pile-h);
    border: 2px solid #d3d3d3;
    background: #808080;
    position: relative;
    border-style: solid;
    flex-shrink: 0;
  }
  .foundation, .tableau { border-style: dashed; }

  .card {
    width: calc(100% - 10px);
    height: calc(100% - 14px);
    border: 1px solid #003366;
    background: #fff;
    position: absolute;
    left: 5px;
    top: 5px;
    padding: 6px;
    display: flex;
    align-items: flex-start;
    justify-content: flex-start;
    font-size: clamp(12px, 2.4vw, 20px);
    user-select: none;
    cursor: move;
    touch-action: none;
  }
  .card.red { color: red; }
  .card.face-down {
    background: #000;
    color: #fff;
    cursor: default;
  }
  .card.moving { opacity: 0.5; }

  #tableau-row {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button {
    padding: 10px 16px;
    font-size: clamp(12px, 2.5vw, 14px);
    background: linear-gradient(to bottom, #f2f2f2, #d9d9d9);
    border: 1px solid #888;
    border-radius: 4px;
    box-shadow: inset 0 1px 0 #fff, 0 1px 2px rgba(0,0,0,0.2);
    cursor: pointer;
  }
  button:hover { background: linear-gradient(to bottom, #ffffff, #cfcfcf); }
  button:active {
    background: linear-gradient(to bottom, #cfcfcf, #ffffff);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }

  .pile.drag-over {
    outline: 3px dashed rgba(255,255,255,0.7);
    outline-offset: -3px;
  }

  #touch-ghost {
    position: absolute;
    pointer-events: none;
    z-index: 9999;
  }

  #reshuffle-circle {
    position: absolute;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: clamp(20px, 4vw, 30px); /* Larger refresh symbol */
    color: #003366; /* Blue color for the symbol */
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
  }
  #reshuffle-circle.visible {
    opacity: 1;
  }
  #reshuffle-circle.spin {
    animation: spin 0.5s linear;
  }
  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @media (max-width: 700px) {
    .top-bar {
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }
    .controls { order: 2; }
  }
</style>
</head>
<body>
<!-- HTML Structure -->
  <h1>Solitaire</h1>

  <div class="board">
    <div class="top-bar">
      <div class="top-row">
        <div class="piles-group">
          <div id="stock" class="pile" onclick="drawCard()">
            <div id="reshuffle-circle">↻</div>
            <div id="stock-card"></div>
          </div>
          <div id="waste" class="pile"></div>
          <div id="foundation1" class="pile foundation"></div>
          <div id="foundation2" class="pile foundation"></div>
          <div id="foundation3" class="pile foundation"></div>
          <div id="foundation4" class="pile foundation"></div>
        </div>
      </div>
      <div class="controls">
        <button onclick="newGame()">New Game</button>
        <button onclick="window.location.href='http://www.protoncube.com/'">Back to Calculator</button>
      </div>
    </div>

    <div id="tableau-row">
      <div id="tableau1" class="pile tableau"></div>
      <div id="tableau2" class="pile tableau"></div>
      <div id="tableau3" class="pile tableau"></div>
      <div id="tableau4" class="pile tableau"></div>
      <div id="tableau5" class="pile tableau"></div>
      <div id="tableau6" class="pile tableau"></div>
      <div id="tableau7" class="pile tableau"></div>
    </div>
  </div>

<script>
<!-- JavaScript Data -->
const suits = ['♠', '♣', '♥', '♦'];
const ranks = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
let deck = [], stock = [], waste = [], foundations = [[],[],[],[]], tableau = [[],[],[],[],[],[],[]];

let touchDragData = null;
let lastTapTime = 0;

<!-- JavaScript Setup Functions -->
function createDeck(){
  deck = [];
  for (let suit of suits){
    for (let rank of ranks){
      deck.push({ suit, rank, color: (suit === '♥' || suit === '♦') ? 'red' : 'black', faceUp: false });
    }
  }
  shuffle(deck);
}

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function dealCards(){
  stock = []; waste = []; foundations = [[],[],[],[]]; tableau = [[],[],[],[],[],[],[]];
  const deckCopy = deck.slice();
  for (let i = 0; i < 7; i++){
    for (let j = i; j < 7; j++){
      const card = deckCopy.pop();
      card.faceUp = (i === j);
      tableau[j].push(card);
    }
  }
  stock = deckCopy;
  renderWithBindings();
}

<!-- JavaScript Rendering Functions -->
function render(){
  // Stock
  const stockCardEl = document.getElementById('stock-card');
  stockCardEl.innerHTML = stock.length ? '<div class="card face-down"></div>' : '';
  const reshuffleCircle = document.getElementById('reshuffle-circle');
  reshuffleCircle.classList.toggle('visible', stock.length === 0);

  // Waste
  const wasteEl = document.getElementById('waste');
  wasteEl.innerHTML = '';
  if (waste.length > 0){
    wasteEl.appendChild(createCardElement(waste[waste.length - 1], 'waste', waste.length - 1));
  }

  // Foundations
  for (let i = 0; i < 4; i++){
    const fEl = document.getElementById(`foundation${i + 1}`);
    fEl.innerHTML = '';
    if (foundations[i].length > 0){
      fEl.appendChild(createCardElement(foundations[i][foundations[i].length - 1], `foundation${i + 1}`, foundations[i].length - 1));
    }
  }

  // Tableau
  for (let i = 0; i < 7; i++){
    const tEl = document.getElementById(`tableau${i + 1}`);
    tEl.innerHTML = '';
    tableau[i].forEach((card, index) => {
      const el = createCardElement(card, `tableau${i + 1}`, index);
      el.style.top = `${index * 20}px`;
      tEl.appendChild(el);
    });
  }
}

function createCardElement(card, pileId, index){
  const div = document.createElement('div');
  div.className = 'card' + (card.faceUp ? '' : ' face-down');

  if (card.faceUp){
    div.textContent = `${card.rank}${card.suit}`;
    div.classList.add(card.color);

    div.draggable = true;
    div.addEventListener('dragstart', e => dragStart(e, pileId, index));

    const pileArr = getPileArray(pileId);
    const isLast = pileArr && index === pileArr.length - 1 && (pileId === 'waste' || pileId.startsWith('tableau'));
    if (isLast){
      div.addEventListener('click', () => autoMoveToFoundation(pileId, index));
    }

    div.addEventListener('touchstart', e => handleCardTouchStart(e, pileId, index), { passive: false });
  }

  div.addEventListener('dragover', e => e.preventDefault());
  div.addEventListener('drop', e => drop(e, pileId));
  return div;
}

function renderWithBindings(){
  render();
  attachPileDropTargets();
}

<!-- JavaScript Drag-and-Drop Handling -->
function isValidSequence(cards){
  for (let k = 1; k < cards.length; k++){
    if (ranks.indexOf(cards[k].rank) !== ranks.indexOf(cards[k - 1].rank) - 1) return false;
    if (cards[k].color === cards[k - 1].color) return false;
  }
  return true;
}

function dragStart(e, pileId, index){
  const src = getPileArray(pileId);
  const moving = src.slice(index);

  if (pileId.startsWith('tableau') && moving.length > 1 && !isValidSequence(moving)){
    e.preventDefault();
    return;
  }

  e.dataTransfer.setData('text/plain', JSON.stringify({ pileId, index }));
}

function attachPileDropTargets(){
  document.querySelectorAll('.pile').forEach(pileEl => {
    pileEl.addEventListener('dragover', e => { e.preventDefault(); pileEl.classList.add('drag-over'); });
    pileEl.addEventListener('dragleave', () => pileEl.classList.remove('drag-over'));
    pileEl.addEventListener('drop', e => { pileEl.classList.remove('drag-over'); drop(e, pileEl.id); });
  });
}

<!-- JavaScript Touch Handling -->
function handleCardTouchStart(e, pileId, index){
  if (!getPileArray(pileId)[index].faceUp) return;
  e.preventDefault();

  const now = Date.now();
  if (now - lastTapTime < 300){
    autoMoveToFoundation(pileId, index);
    lastTapTime = 0;
    return;
  }
  lastTapTime = now;

  const src = getPileArray(pileId);
  const moving = src.slice(index);
  if (pileId.startsWith('tableau') && moving.length > 1 && !isValidSequence(moving)) return;

  touchDragData = { pileId, index };

  const ghost = document.createElement('div');
  ghost.id = 'touch-ghost';
  moving.forEach((card, i) => {
    const mini = document.createElement('div');
    mini.className = 'card' + (card.faceUp ? '' : ' face-down');
    if (card.faceUp){
      mini.textContent = `${card.rank}${card.suit}`;
      mini.classList.add(card.color);
    }
    mini.style.position = 'absolute';
    mini.style.left = '0';
    mini.style.top = `${i * 20}px`;
    mini.style.width = `calc(${getComputedStyle(document.querySelector('.pile')).width} - 10px)`;
    mini.style.height = `calc(${getComputedStyle(document.querySelector('.pile')).height} - 14px)`;
    ghost.appendChild(mini);
  });
  document.body.appendChild(ghost);

  document.addEventListener('touchmove', handleTouchMove, { passive: false });
  document.addEventListener('touchend', handleTouchEnd, { passive: false });
}

function handleTouchMove(e){
  if (!touchDragData) return;
  e.preventDefault();
  const t = e.touches[0];
  const ghost = document.getElementById('touch-ghost');
  if (ghost){
    ghost.style.left = (t.pageX - parseInt(getComputedStyle(document.querySelector('.pile')).width)/2) + 'px';
    ghost.style.top  = (t.pageY - parseInt(getComputedStyle(document.querySelector('.pile')).height)/2) + 'px';
  }
}

function handleTouchEnd(e){
  if (!touchDragData) return;

  const t = e.changedTouches[0];
  const el = document.elementFromPoint(t.clientX, t.clientY);
  const targetPileEl = el ? el.closest('.pile') : null;

  const ghost = document.getElementById('touch-ghost');
  if (ghost) ghost.remove();

  if (targetPileEl){
    drop(new Event('drop'), targetPileEl.id);
  }

  touchDragData = null;
  document.removeEventListener('touchmove', handleTouchMove);
  document.removeEventListener('touchend', handleTouchEnd);
}

<!-- JavaScript Game Logic -->
function getPileArray(id){
  if (id === 'waste') return waste;
  if (id.startsWith('foundation')) return foundations[parseInt(id[10]) - 1];
  if (id.startsWith('tableau')) return tableau[parseInt(id[7]) - 1];
  return null;
}

function isValidMove(targetId, movingCard, targetPile){
  if (!movingCard) return false;

  if (targetId.startsWith('foundation')){
    if (targetPile.length === 0) return movingCard.rank === 'A';
    return movingCard.suit === targetPile[targetPile.length - 1].suit &&
           ranks.indexOf(movingCard.rank) === ranks.indexOf(targetPile[targetPile.length - 1].rank) + 1;
  } else if (targetId.startsWith('tableau')){
    if (targetPile.length === 0) return movingCard.rank === 'K';
    const topCard = targetPile[targetPile.length - 1];
    return movingCard.color !== topCard.color &&
           ranks.indexOf(movingCard.rank) === ranks.indexOf(topCard.rank) - 1;
  }
  return false;
}

function drop(e, targetPileId){
  e.preventDefault();

  let data = null;
  if (e.dataTransfer){
    const text = e.dataTransfer.getData('text');
    if (text) data = JSON.parse(text);
  }
  if (!data && touchDragData) data = touchDragData;
  if (!data) return;

  const { pileId, index } = data;
  if (pileId === targetPileId) return;

  const sourcePile = getPileArray(pileId);
  const targetPile = getPileArray(targetPileId);
  if (!sourcePile || !targetPile) return;

  let movingCards = sourcePile.slice(index);

  if (pileId.startsWith('tableau') && movingCards.length > 1 && !isValidSequence(movingCards)) return;

  if (targetPileId.startsWith('foundation') && movingCards.length > 1){
    movingCards = [movingCards[0]];
  }

  if (isValidMove(targetPileId, movingCards[0], targetPile)){
    sourcePile.splice(index, movingCards.length);
    targetPile.push(...movingCards);

    if (pileId.startsWith('tableau') && sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp){
      sourcePile[sourcePile.length - 1].faceUp = true;
    }
    renderWithBindings();
    checkWin();
  }
}

function drawCard(){
  console.log('drawCard called, stock length:', stock.length, 'waste length:', waste.length);
  if (stock.length > 0){
    const card = stock.pop();
    card.faceUp = true;
    waste.push(card);
    console.log('Drew card:', card);
  } else if (waste.length > 0){
    const reshuffleCircle = document.getElementById('reshuffle-circle');
    reshuffleCircle.classList.add('spin');
    setTimeout(() => reshuffleCircle.classList.remove('spin'), 500);
    stock = waste.reverse().map(c => ({ ...c, faceUp: false }));
    waste = [];
    console.log('Reshuffled, new stock length:', stock.length);
  } else if (isAllFaceUp()){
    console.log('All face up, running autoComplete');
    autoComplete();
  }
  renderWithBindings();
}

function isAllFaceUp(){
  return tableau.every(pile => pile.every(card => card.faceUp));
}

function autoComplete(){
  let moved;
  do {
    moved = false;
    if (waste.length > 0){
      const card = waste[waste.length - 1];
      for (let i = 0; i < 4; i++){
        const f = foundations[i];
        if (isValidMove(`foundation${i + 1}`, card, f)){
          waste.pop(); f.push(card); moved = true; break;
        }
      }
    }
    for (let j = 0; j < 7; j++){
      const t = tableau[j];
      if (t.length > 0){
        const card = t[t.length - 1];
        for (let i = 0; i < 4; i++){
          const f = foundations[i];
          if (isValidMove(`foundation${i + 1}`, card, f)){
            t.pop(); f.push(card); moved = true; break;
          }
        }
      }
    }
  } while (moved);
  renderWithBindings();
  checkWin();
}

function autoMoveToFoundation(pileId, index){
  const sourcePile = getPileArray(pileId);
  if (!sourcePile || index !== sourcePile.length - 1) return;
  const card = sourcePile[index];
  for (let i = 0; i < 4; i++){
    const f = foundations[i];
    if (isValidMove(`foundation${i + 1}`, card, f)){
      sourcePile.pop();
      f.push(card);
      if (pileId.startsWith('tableau') && sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp){
        sourcePile[sourcePile.length - 1].faceUp = true;
      }
      renderWithBindings();
      checkWin();
      return;
    }
  }
}

function checkWin(){
  const total = foundations.reduce((s,f) => s + f.length, 0);
  if (total === 52) alert('Congratulations! You won!');
}

function newGame(){
  createDeck();
  dealCards();
}

<!-- JavaScript Boot Process -->
newGame();
</script>
</body>
</html>
